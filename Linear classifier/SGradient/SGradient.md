Метод стохастического градиента

*Метод линейного классификатора* (linear classifier) — алгоритм классификации, основанный на построении линейной разделяющей поверхности. В случае двух классов разделяющей поверхностью является гиперплоскость, которая делит пространство признаков на два полупространства. В случае большего числа классов разделяющая поверхность кусочно-линейна.

Стохастический градиентный метод — один из основных подходов к реализации градиентного спуска для решения задачи минимизации эмпирического риска. Применяется для подбора вектора весов w в линейном классификаторе. Это пошаговый алгоритм, на каждой итерации которого вектор w изменяется в направлении наибольшего убывания функционала Q (то есть в направлении антиградиента):
$$
w \, {:=} \, w \, - \, \eta \nabla Q(w)
$$
Адаптивный линейный элемент(адаптивный линейный нейрон или ADALINE) - частный случай линейного классификатора или искусственной нейронной сети с одним слоем. Схема работы ADALINE несколько напоминает работу биологического нейрона. На вход подаётся вектор импульсов, состоящий из числовых признаков. Внутри нейрона импульсы складываются с некоторыми весами и, если суммарный импульс превысит порог активации, то нейрон возбуждается и выдаёт некоторое значение. Обучение ADALINE заключается в подборе "наилучших" значений вектора весов. Для этого используется дельта-правило, предложенное Видроу и Хоффом.
$$
w=w-\eta(\langle w,{x}_{i}-{y}_{i} \rangle){x}_{i}
$$

Экспериментально было установлено, что при синхронном возбуждении двух связанных нервных клеток синаптическая связь между ними усиливается. Чем чаще синапс угадывает правильный ответ, тем сильнее становится связь. Если же синапс начинает часто ошибаться или вообще перестаёт использоваться, связь ослабевает, информация начинается забываться. Таким образом, память реализуется в синапсах. В математической модели нейрона роль памяти играет вектор синаптических весов.

Цель обучения перцептрона состояла в том, чтобы при подаче на фотоэлементы закодированного образа на его выходе появлялась логическая единица в случае принадлежности поданного образа к заранее определенному классу и ноль в противном случае. Логика обучения следующая: если сигнал персептрона при некотором образе верен, то ничего корректировать не надо, если нет — производится корректировка весов сумматора.

Три вероятных случая классификации объединяются в правило Хэбба:
$$
\text{если } \langle w,{x}_{i} \rangle{y}_{i}<0 \text{ то } w=w+\eta{x}_{i}{y}_{i}
$$

Логистическая регрессия — метод построения линейного классификатора, позволяющий оценивать апостериорные вероятности принадлежности объектов классам. Метод логистической регрессии основан на довольно сильных вероятностных предположениях, которые имеют несколько интересных последствий: линейный классификатор оказывается оптимальным байесовским; однозначно определяется функция потерь; можно вычислять не только принадлежность объектов классам, но также получать и численные оценки вероятности их принадлежности.

Логистическое правило обновления весов для градиентного шага в методе стохастического градиента:
$$
w=w+\eta{x}_{i}{y}_{i}\sigma(-\langle w,{x}_{i} \rangle {y}_{i})
$$

Как правило, логистическая регрессия дает лучшие результаты по сравнению с линейным дискриминантом Фишера (поскольку она основана на менее жестких гипотезах), а также по сравнению с дельта-правилом и правилом Хэбба (поскольку она использует "более правильную" функцию потерь).

###  Алгоритм

1. На вход подаётся выборка, параметр сглаживания и тип алгоритма (ADALINE, правило Хэбба, логистическая регрессия)
2. Генерируется вектор весов и оценивается эмпирический риск
3. На каждом шаге выбирается один из объектов выборки, и для него делается шаг градиентного спуска
4. Процедура выполняется до тех пор, пока не будет сделано слишком много шагов или пока не стабилизируется значение эмпирического риска
5. На выходе - вектор весов

### Программная реализация алгоритма

```R
dataNorm <- function(xl) {
  n <- dim(xl)[2]
  for (i in 1:n) {
    mn <- min(xl[ ,i])
    mx <- max(xl[ ,i])
    if (mx>mn) {
      xl[ ,i] <- (xl[ ,i]-mn)/(mx-mn)
    }
  }
  return (xl)
}


randomWeight <- function(n) {
  return (runif(n,min=-0.5/n,max=0.5/n))
}


zeroWeight <- function(n) {
  return (array(0.0,n))
}


adalineL <- function(w,x) {   #L для ADALINE
  n <- length(w)
  return ((c(w%*%x[1:n])*x[n+1]-1)^2)
}


adalineLL <- function(w,x) {   #L' для ADALINE
  n <- length(w)
  return (x[1:n]*(2.0*(c(w%*%x[1:n])*x[n+1]^2-x[n+1])))
}


hebbL <- function(w,x) {   #L для правила Хэбба
  n <- length(w)
  return (max(-c(w%*%x[1:n])*x[n+1],0))
}


hebbLL <- function(w,x) {   #L' для правила Хэбба
  n <- length(w)
  return (-x[1:n]*x[n+1])
}


logisticL <- function(w,x) {   #L для логистической регрессии
  n <- length(w)
  return (log2(1+exp(-c(w%*%x[1:n])*x[n+1])))
}


logisticLL <- function(w,x) {   #L' для логистической регрессии
  n <- length(w)
  return (x[1:n]*x[n+1]*(-1.0/(exp(c(w%*%x[1:n])*x[n+1])*log(2)+log(2))))
}


error <- function(w,objects,func) {   #функция подсчёта ошибки
  res <- 0
  l <- dim(objects)[1]
  for (i in 1:l) {
    res <- res+func(w,objects[i, ])
  }
  return (res)
}


findErrors <- function(w,objects,func) {   #функция поиска всех неправильно классифицируемых объектов для Хэбба
  res <- numeric()
  l <- dim(objects)[1]
  for (i in 1:l) {
    margin <- func(w,objects[i, ])
    if (margin>0 || c(w%*%objects[1:length(w)])==0)   #нулевое значение <w,x> или положительный отступ - ошибка
      res <- c(res,i)
  }
  return (res)
}


step <- function(w,obj,func) {   #градиентный шаг
  res <- func(w,obj)
  return (res)
}


gradient <- function(xl,lambda,funcL,funcLL,isHebb=FALSE,weightInit=randomWeight) {
  l <- dim(xl)[1]
  n <- dim(xl)[2]-1
  w <- weightInit(n)   #инициализируем массив весов
  Q <- error(w,xl,funcL)    #считаем стартовое значение эмперического риска
  Qprev <- array(Q-100.0,10)   #массив для проверки нормализации эмпирического риска
  class <- sample(c(-1,1),1)    #один из случайных классов, для чередования
  steps <- 0
  nu <- 1
  while (TRUE) {
    steps <- steps+1
    if (isHebb==TRUE) {   #для правила Хэбба берём только плохие
      errored <- findErrors(w,xl,funcL)   #список плохих объектов
      if (length(errored)==0) break
      obj <- sample(errored,1)    #выбираем случайный
    } else {
      obj <- sample(which(xl[ ,n+1]==class,arr.ind=TRUE),1)   #выбираем случайный из предложенного класса
    }
    eps <- error(w,matrix(xl[obj, ],1,n+1),funcL)   #считаем ошибку на объекте
    w <- w-nu*step(w,xl[obj, ],funcLL)   #и делаем градиентный спуск
    Q <- (1-lambda)*Q+lambda*eps    #пересчитываем значение эмперического риска
    class <- -class    #меняем класс на противоположный
    nu <- 1/steps
    if (abs(mean(Qprev)-Q)<1e-3) {   #эмпирический риск стабилизировался
      break
    } else {
      Qprev <- c(Q,Qprev[1:9])
    }
    if (steps==10000) break    #слишком много шагов
  }
  return (w)
}
```

### Результат работы алгоритма

Результатом работы алгоритма будут следующие графики:

![SGradient1](SGradient1.png)

![SGradient2](SGradient2.png)